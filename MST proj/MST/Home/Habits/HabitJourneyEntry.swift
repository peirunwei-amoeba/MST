//
//  HabitJourneyEntry.swift
//  MST
//
//  Copyright © 2025 Pei Runwei. All rights reserved.
//
//  This Source Code Form is subject to the terms of the PolyForm Strict
//  License 1.0.0. You may not use, modify, or distribute this file except
//  in compliance with the License. A copy of the License is located at:
//  https://polyformproject.org/licenses/strict/1.0.0
//
//  Required Notice: Copyright Pei Runwei (https://github.com/peirunwei-amoeba)
//

import Foundation
import SwiftData

/// One story paragraph for a habit's journey, generated by Apple Intelligence after each check-in.
@Model
final class HabitJourneyEntry {
    @Attribute(.unique) var id: UUID
    var habitId: UUID
    var habitTitle: String
    var date: Date
    /// Which check-in this paragraph corresponds to (1 = first time, 2 = second, etc.)
    var checkinNumber: Int
    /// Full story text. Image scene placeholders are embedded as `!word_word_word`.
    var storyText: String
    /// JSON-encoded [String: String] mapping each `!marker` → absolute file path of the generated image.
    var imagePathsJSON: String

    // MARK: - Computed helpers

    var imagePaths: [String: String] {
        get {
            guard let data = imagePathsJSON.data(using: .utf8),
                  let dict = try? JSONDecoder().decode([String: String].self, from: data)
            else { return [:] }
            return dict
        }
        set {
            let data = (try? JSONEncoder().encode(newValue)) ?? Data()
            imagePathsJSON = String(data: data, encoding: .utf8) ?? "{}"
        }
    }

    init(habitId: UUID, habitTitle: String, date: Date = Date(), checkinNumber: Int, storyText: String = "") {
        self.id = UUID()
        self.habitId = habitId
        self.habitTitle = habitTitle
        self.date = date
        self.checkinNumber = checkinNumber
        self.storyText = storyText
        self.imagePathsJSON = "{}"
    }

    // MARK: - Text segment parsing

    enum StorySegment {
        case text(String)
        case imageMarker(String)   // The marker key, e.g. "mountain_trail_sunset"
    }

    /// Parse storyText into alternating text/imageMarker segments for rendering.
    var segments: [StorySegment] {
        Self.parse(storyText)
    }

    static func parse(_ text: String) -> [StorySegment] {
        guard !text.isEmpty else { return [] }

        var segments: [StorySegment] = []
        var remaining = text

        let pattern = try? NSRegularExpression(pattern: #"!([a-zA-Z][a-zA-Z_]*[a-zA-Z])"#)

        while !remaining.isEmpty {
            guard let pat = pattern else {
                segments.append(.text(remaining))
                break
            }
            let range = NSRange(remaining.startIndex..., in: remaining)
            if let match = pat.firstMatch(in: remaining, range: range) {
                let matchRange = Range(match.range, in: remaining)!
                let markerRange = Range(match.range(at: 1), in: remaining)!

                // Text before the marker
                let before = String(remaining[remaining.startIndex..<matchRange.lowerBound])
                if !before.trimmingCharacters(in: .whitespaces).isEmpty {
                    segments.append(.text(before))
                }

                // The image marker (without the leading !)
                segments.append(.imageMarker(String(remaining[markerRange])))

                remaining = String(remaining[matchRange.upperBound...])
            } else {
                segments.append(.text(remaining))
                break
            }
        }
        return segments
    }

    // MARK: - Image directory

    static var imagesDirectory: URL {
        let docs = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let dir = docs.appendingPathComponent("JourneyImages", isDirectory: true)
        try? FileManager.default.createDirectory(at: dir, withIntermediateDirectories: true)
        return dir
    }

    func imageFilePath(for marker: String) -> URL {
        Self.imagesDirectory.appendingPathComponent("\(id.uuidString)_\(marker).png")
    }

    func savedImageURL(for marker: String) -> URL? {
        let path = imagePaths[marker] ?? ""
        guard !path.isEmpty else { return nil }
        let url = URL(fileURLWithPath: path)
        return FileManager.default.fileExists(atPath: url.path) ? url : nil
    }

    func saveImage(at sourceURL: URL, for marker: String) {
        let dest = imageFilePath(for: marker)
        try? FileManager.default.copyItem(at: sourceURL, to: dest)
        var paths = imagePaths
        paths[marker] = dest.path
        imagePaths = paths
    }
}
